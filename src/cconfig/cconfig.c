/* 
 * Authors: Patrick Hochstenbach <Patrick.Hochstenbach@UGent.be>
 *
 * $Id: cconfig.c,v 1.4 2006/12/19 08:33:12 hochstenbach Exp $
 * 
 */
#include <hash.h>
#include "cconfig.h"

#define	BUFF_SIZE 1024

typedef void (*sighandler_t)(int);

/* Load a configuration file into memory. On success
 * the function returns a positive integer which must
 * be used in subsequent calls to cconf routines.
 * On error the function returns -1.
 */
int	config_open(const char *filename, int config_mode) {
	HASH	h;
	char 	name[BUFF_SIZE];
	char 	value[BUFF_SIZE];
	char	buffer[BUFF_SIZE];
	char	format[32];
	int	fd;
	FILE	*fp;

	h = hash_new();


	if (h == NULL) {
		warn("config_load - failed to hash_new()");
		return -1;
	}

	/* Open the configuration file in readwrite mode so we can lock it. */
	fd = open(filename, config_mode == READ_WRITE  ? O_RDWR : O_RDONLY, 0);

	if (fd == -1) {
		hash_free(h);
		warn("config_load - failed to open %s", filename);
		return -1;
	}

#ifdef __svr4__
        if (config_mode == READ_WRITE && lockf(fd, F_LOCK, 0) == -1) {
#else
        if (config_mode == READ_WRITE && flock(fd, LOCK_EX) == -1) {
#endif
		hash_free(h);
                warn("config_load - failed to lock %s", filename);
                return(-1);
        }

	fp  = fdopen(fd, config_mode == READ_WRITE ? "r+" : "r");

	if (fp == NULL) {
		hash_free(h);
		warn("config_load - fdopen() failed");
		close(fd);
		return -1;
	}

	rewind(fp);

	sprintf(format, "%%%ds %%%d[^\n]", BUFF_SIZE, BUFF_SIZE);

	while ( fgets(buffer, BUFF_SIZE, fp) != NULL) {
		if (buffer[0] == '#' || (buffer[0] == '_' && buffer[1] == '_')) {
			continue;
		}

		if (sscanf(buffer, format, name, value) == 2) {
			debug("config_load - storing %s:%s", name,value);
			hash_add(h, name, value);
		}

	}

	/* Don't close the file, store the address to the filepointer in the
	 * hash file. Close this file in config_close.
	 */
	sprintf(buffer,"%p", fp);
	hash_add(h, "__FP__", buffer);	
	/* fclose(fp); */

	hash_add(h, "__FILENAME__", filename);
	hash_add(h, "__FILEMODE__", config_mode == READ_WRITE ? "READ_WRITE" : "READ");

	/* Hack: return the memory location of the HASH to the
	 * caller. We can cast this memory location back to the
	 * value of the HASH by casting the pointer back to a
	 * HASH:
	 *
	 *   HASH h = (HASH) <memory_location>
	 */
	return (int) h;
}

/* Returns the content of the param field in the
 * configuration file. 
 */
char	*config_param(int handle, const char *token) {
	HASH h;
	char *value;

	h = (HASH) handle;

	value = hash_val(h, token);

	debug("config_param - retrieving %s:%s", token, value == NULL ? "(null)" : value );

	if (value == NULL) {
		return "";
	}
	else {
		return value;
	}
}

/* Add a parameter to a configuration file.
 */
int	config_param_add(int handle, const char *token, const char *value) {
	HASH h;
	
	h = (HASH) handle;

	hash_add(h, token, value);

	return(0);
}

/* Set the parameter of the configuration file.
 */
int	config_param_set(int handle, const char *token, const char *value) {
	HASH h;

	h = (HASH) handle;

	hash_del(h, token);
	
	hash_add(h, token, value);

	return(0);
}

/* Delete a parameter from the configuration file.
 */
int	config_param_del(int handle, const char *token) {
	HASH h;

	h = (HASH) handle;

	hash_del(h, token);

	return(0);
}

/* Write a configuration file back to disk (add changes) 
 */
int	config_save(int handle) {
	int	i;
	HASH	h;
	FILE	*fp;
	char	*key, *val;
	int	fh;
	sighandler_t sig_int;
	sighandler_t sig_term;
	sighandler_t sig_hup;

	h = (HASH) handle;

	/* Read the string address from the HASH cast it into a
	 * file pointer and close the file
	 */
	sscanf( hash_val(h,"__FP__") ,"%x",&i);

	fp = (FILE *)i;

	/* Now the delicate part of the code. We overwrite the configuration file.
	 * In the future we should dump this code and go for a gdbm solution.
         */
	rewind(fp);

	/* Ignore signals and save the previous handler to set them again at the end of the code */	
	sig_int  = signal(SIGINT, SIG_IGN);
	sig_term = signal(SIGTERM, SIG_IGN);
	sig_hup  = signal(SIGHUP, SIG_IGN);

	fh = fileno(fp);

	ftruncate(fh,0);

	hash_next_reset(h);

	fprintf(fp, "# DO NOT EDIT THIS FILE MANUALLY!\n"); fflush(fp);

	while ( (key = hash_next_key(h)) != NULL ) {
		if (strlen(key) >= 2 && key[0] == '_' && key[1] == '_') continue;

		val = hash_val(h, key);

		if (val != NULL) {
			fprintf(fp, "%s %s\n", key, val); fflush(fp);
		}
	}

	signal(SIGINT, sig_int);
	signal(SIGTERM, sig_term);
	signal(SIGHUP, sig_hup);

	return(0);
}

/* Free a configuration structure pointed at by handle.
 */
void	config_close(int handle) {
	int	i;
	HASH 	h;

	h = (HASH) handle;

	/* Read the string address from the HASH cast it into a
	 * file pointer and close the file
	 */
	sscanf( hash_val(h,"__FP__") ,"%x",&i);

	fclose((FILE *) i);

	hash_free(h);
}
